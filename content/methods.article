Méthodes et interfaces
Cette leçon couvre les méthodes et les interfaces, les constructions qui définissent des objets et leur comportement.

Les auteurs de Go
https://golang.org

* Méthodes

Go ne dispose pas des classes.
Cependant, vous pouvez définir des méthodes sur les types.

Une méthode est une fonction avec un argument de _récepteur_ spécial.

Le récepteur apparaît dans sa propre liste d'argument entre le mot clé `func` et
le nom de la méthode.

Dans cet exemple, la méthode `Abs` possède un récepteur de type `Vertex` nommé `v`.

.play methods/methods.go

* Les méthodes sont des fonctions

Rappelez-vous : une méthode est juste une fonction avec un argument de récepteur.

Voici `Abs` écrit comme une fonction régulière sans changement de fonctionnalité.

.play methods/methods-funcs.go

* Méthodes continué

Vous pouvez déclarer une méthode sur les types non-struct, aussi.

Dans cet exemple, nous voyons un type numérique `MyFloat` avec une méthode `Abs`.

Vous ne pouvez que déclarer une méthode avec un récepteur dont le type est défini dans le même
paquet que la méthode.
Vous ne pouvez pas déclarer une méthode avec un récepteur dont le type est défini dans un autre
paquet (ce-qui comprend les types intégrés comme `int`).

.play methods/methods-continued.go

* Récepteurs de Pointeur

Vous pouvez déclarer des méthodes avec des récepteurs de pointeur.

Cela signifie que le type de récepteur a la syntaxe littérale `*T` pour un certain type `T`.
(Aussi, `T` ne peut pas être lui-même un pointeur comme `*int`.)

Par exemple, la méthode `Scale` est ici défini sur `*Vertex`.

Les méthodes avec récepteurs de pointeur peuvent modifier la valeur à laquelle le récepteur
pointes (comme `Scale` le fait ici).
Comme les méthodes ont souvent besoin de modifier leur récepteur, les récepteurs de pointeur sont plus
communs que les récepteurs de valeur.

Essayez de retirer le `*` de la déclaration de la fonction `Scale` sur la ligne 16
et observez comment le comportement du programme change.

Avec un récepteur de valeur, la méthode `Scale` fonctionne sur une copie de la valeur
original `Vertex`.
(Ceci est le même comportement que pour toute autre argument de la fonction.)
La méthode `Scale` doit disposer d'un récepteur de pointeur pour modifier la valeur `Vertex`
déclarée dans la fonction `main`.

.play methods/methods-pointers.go

* Pointeurs et fonctions

Ici, nous voyons les méthodes `Abs` et `Scale` réécrite comme des fonctions.

Encore une fois, essayez de supprimer le `*` de la ligne 16.
Pouvez-vous voir pourquoi il y a un changement de comportement?
Quoi d'autre avez-vous eu besoin de changer pour que l'exemple compile?

(Si vous n'êtes pas sûr, continuer à la page suivante.)

.play methods/methods-pointers-explained.go

* Méthodes et pointeur d'indirection

En comparant les deux programmes précédents, vous remarquerez peut-être que
des fonctions avec un argument pointeur doivent prendre un pointeur :

	var v Vertex
	ScaleFunc(v)  // Compile error!
	ScaleFunc(&v) // OK

tandis que les méthodes avec des récepteurs de pointeur prennent une valeur ou un pointeur comme
récepteur quand ils sont appelés :

	var v Vertex
	v.Scale(5)  // OK
	p := &v
	p.Scale(10) // OK

Pour la déclaration `v.Scale(5)`, même si `v` est une valeur et non un pointeur,
la méthode avec le récepteur de pointeur est appelée automatiquement.
Autrement dit, à titre de commodité, Go interprète la déclaration `v.Scale(5)` comme
`(&v).scale(5)` car la méthode `Scale` possède un récepteur de pointeur.

.play methods/indirection.go

* Méthodes et pointeur d'indirection (2)

La chose équivalente se produit dans le sens inverse.

Des fonctions qui prennent un argument de valeur doivent prendre une valeur de ce type spécifique :

	var v Vertex
	fmt.Println(AbsFunc(v))  // OK
	fmt.Println(AbsFunc(&v)) // Compile error!

tandis que les méthodes avec des récepteurs de valeur prennent une valeur ou un pointeur comme
récepteur quand ils sont appelés :

	var v Vertex
	fmt.Println(v.Abs()) // OK
	p := &v
	fmt.Println(p.Abs()) // OK

Dans ce cas, l'appel de méthode `p.Ab()` est interprété comme `(*p).Ab()`.

.play methods/indirection-values.go

* Choix d'un récepteur de valeur ou pointeur

Il y a deux raisons d'utiliser un récepteur de pointeur.

La premiere est le cas ou la méthode peut modifier la valeur du recepteur pointé.

La deuxième afin d'éviter la copie de la valeur sur chaque appel de méthode.
Cela peut être plus efficace si le récepteur est une grande struct, par exemple.

Dans cet exemple, `Scale` et `Abs` sont avec le type de récepteur `*Vertex`,
même si la méthode `Abs` n'a pas modifier son récepteur.

En général, toutes les méthodes sur un type donné doivent avoir soit une valeur ou un pointeur
récepteurs, mais pas un mélange des deux.
(Nous verrons pourquoi dans les prochaines pages.)

.play methods/methods-with-pointer-receivers.go

* Interfaces

Un type d'interface est définie par un ensemble de méthodes.

Une valeur de type d'interface peut contenir n'importe quelle valeur qui implémente ces méthodes.

*Note*:* il y a une erreur dans le code d'exemple sur la ligne 22.
`Vertex` (le type de valeur) ne satisfait pas `Abser` parce que
la méthode `Abs` est définie uniquement sur `*Vertex` (le type de pointeur).

.play methods/interfaces.go

* Les interfaces sont satisfaits implicitement

Un type implémente une interface en mettant en œuvre les méthodes.
Il n'y a aucune déclaration explicite d'intention ; pas de mot-clé « implements ».

Les interfaces implicites découple les paquets d'implémentation des paquets qui définissent les interfaces : aucun ne dépend de l'autre.

Il encourage également la définition précises des interfaces, parce que vous n'avez pas à trouver chaque mise en œuvre et l'étiqueter avec le nom de la nouvelle interface.

[[https://golang.org/pkg/io/][le Paquet io]] définis `Reader` et `Writer` ; pour vous.

.play methods/interfaces-are-satisfied-implicitly.go

* Stringers

L'une des interfaces les plus répandues est [[//golang.org/pkg/fmt/#Stringer][`Stringer`]] défini par le paquet [[//golang.org/pkg/fmt /][`fmt`]].

	type Stringer interface {
		String() string
	}

Un `Stringer` est un type qui peut se décrire comme une chaîne. Le paquet `fmt`
(et bien d'autres) recherche cette interface pour imprimer les valeurs.

.play methods/stringer.go

* Exercice : Stringer

Faire que le type `IPAddr` implémente `fmt.Stringer` pour imprimer l'adresse en
un quad en pointillés.

Par exemple, `IPAddr{1,`2,`3,`4}` devrait s'imprimer comme `"1.2.3.4"`.

.play methods/exercise-stringer.go

* Erreurs

les programmes Go expriment l'état d'erreur avec les valeurs de `error`.

Le type de `error` est une interface intégrée similaire à `fmt.Stringer` :

	type error interface {
		Error() string
	}

(Comme `fmt.Stringer`, le paquet `fmt` recherche l'interface `error` lors
de l'impression des valeurs.)

Les fonctions renvoient souvent une valeur `error`, et le code appelant doit gérer les erreurs
en testant si l'erreur est égale à `nil`.

	i, err := strconv.Atoi("42")
	if err != nil {
		fmt.Printf("ne peut pas convertir un nombre : %v\n", err)
		return
	}
	fmt.Println("entier converti :", i)

Une `error` nul dénote le succès ; une `error` non-nul dénote l'échec.

.play methods/errors.go

* Exercice : erreurs

Copiez la fonction de votre `Sqrt` des [[/flowcontrol/8][exercices antérieurs]] et la modifier pour retourner une valeur `error`.

`Sqrt` doit retourner une valeur d'erreur non-nulle quand on lui donne un nombre négatif, car il ne supporte pas les nombres complexes.

Créer un nouveau type

	type ErrNegativeSqrt float64

et en faire une `error` en lui donnant une

	func (e ErrNegativeSqrt) Error() string

méthode telle que `ErrNegativeSqrt(-2).Error()` renvoie `"cannot`Sqrt`negative`number:`-2"`.

*Note*:* un appel à `fmt.Sprint(e)` à l'intérieur de la méthode `Error` enverra le programme dans une boucle infinie. Vous pouvez éviter cela en convertissant `e` en premier : `fmt.Sprint(float64(e))`. Pourquoi ?

Changer la fonction `Sqrt` pour retourner une valeur `ErrNegativeSqrt` quand un nombre négatif est donné.

.play methods/exercise-errors.go

* Lecteurs (Readers)

Le paquet `io` spécifie l'interface `io.Reader`,
qui représente la fin de lecture d'un flux de données.

La bibliothèque standard de Go contient [[https://golang.org/search?q=Read#Global][plusieurs implémentations]] de ces interfaces, y compris les fichiers, les connexions réseau, les compresseurs, les chiffrements, et d'autres.

L'interface `io.Reader` a une méthode `Read` :

	func (T) Read(b []byte) (n int, err error)

`Read` remplit la tranche d'octets donné avec des données et renvoie le nombre d'octets
peuplé et une valeur d'erreur. Il renvoie une erreur `io.EOF` lorsque le flux
se termine.

L'exemple de code crée un
[[//golang.org/pkg/strings/#Reader][`strings.Reader`]].
et consomme sa sortie 8 octets à la fois.

.play methods/reader.go

* Exercice : lecteurs

Mettre en place un type `Reader` qui émet un flux infini de caractères ASCII
`'A'`.

.play methods/exercise-reader.go

* Exercice : rot13Reader

Un modèle commun est un [[https://golang.org/pkg/io/#Reader][io.Reader]] qui enveloppe une autre `io.Reader`, modifiant le flux d'une certaine façon.

Par exemple, la fonction [[https://golang.org/pkg/compress/gzip/#NewReader][gzip.NewReader]] prend un `io.Reader` (un flux de données compressées) et renvoie un `*gzip.Reader` qui met également en œuvre `io.Reader` (un flux de données décompressées).

Mettre en place un `rot13Reader` qui implémente `io.Reader` et lit un `io.Reader`, modifiant le flux en appliquant la substitution [[https://en.wikipedia.org/wiki/ROT13][rot13]] de chiffrement à tous les caractères alphabétiques.

Le type `rot13Reader` est fourni pour vous.
Faites un `io.Reader` en mettant en œuvre sa méthode`Read`.

.play methods/exercise-rot-reader.go

* Serveurs Web

[[https://golang.org/pkg/net/http/][Paquet http]] sert les requêtes HTTP à l'aide de n'importe quelle valeur qui implémente `http.Handler` :

	package http

	type Handler interface {
		ServeHTTP(w ResponseWriter, r *Request)
	}

Dans cet exemple, le type `Hello` implémente `http.Handler`.

Visitez [[http://localhost:4000/][http://localhost:4000/]] pour voir l'annonce.

#appengine: *Note*:* cet exemple ne fonctionnera pas si le tour est sur l'interface Web.
#appengine: Pour essayer d'écrire des serveurs Web vous voudrez peut-être
#appengine: [[https://golang.org/dl/][installer Go]].

.play methods/web-servers.go

* Exercice : gestionnaires HTTP

Mettre en œuvre les types suivants et définir des méthodes ServeHTTP sur eux. Inscrivez-vous pour gérer des chemins spécifiques à votre serveur web.

	type String string

	type Struct struct {
		Greeting string
		Punct    string
		Who      string
	}

Par exemple, vous devriez être capable d'enregistrer des gestionnaires à l'aide de :

	http.Handle("/string", String("I'm a frayed knot."))
	http.Handle("/struct", &Struct{"Hello", ":", "Gophers!"})

Après le démarrage de votre serveur, vous serez en mesure de visiter
[[http://localhost:4000/string][http://localhost:4000/string]] et
[[http://localhost:4000/struct][http://localhost:4000/struct]].

Pour plus de détails sur la fonction `http.Handle`, voir
[[https://golang.org/pkg/net/http/#Handle][la documentation]].

#appengine: *Note*:* cet exemple ne fonctionnera pas via l'interface utilisateur du tour sur le web.
#appengine: Pour essayer l'écriture, des serveurs Web, vous voudrez peut-être
#appengine: [[https://golang.org/dl/][installer Go]].

.play methods/exercise-http-handlers.go

* Images

[[https://golang.org/pkg/image/#Image][Package image]] définit l'interface `Image` :

	package image

	type Image interface {
		ColorModel() color.Model
		Bounds() Rectangle
		At(x, y int) color.Color
	}

*Note*:* la valeur de retour `Rectangle` de la méthode `Bounds` est en fait une
[[https://golang.org/pkg/image/#Rectangle][`image.Rectangle`]], comme le
déclaration est à l'intérieur du paquet `image`.

(Voir [[https://golang.org/pkg/image/#Image][la documentation]] pour tous les détails.)

Les types `color.Color` et `color.Model` sont également des interfaces, mais nous allons l'ignorer en utilisant les implémentations prédéfinies `color.RGBA` et `color.RGBAModel`. Ces interfaces et les types sont spécifiés par le [[https://golang.org/pkg/image/color/][paquet image/color]]

.play methods/images.go

* Exercice : Images

Souvenez-vous du générateur d'images que vous avez écrit plus tôt ? Écrivons un autre, mais cette fois, il retournera une implémentation de `image.Image` au lieu d'une tranche de données.

Définissez votre propre type `Image`, mettre en œuvre [[https://golang.org/pkg/image/#Image][les méthodes nécessaires]], et appeler `pic.ShowImage`.

`Bounds` devraient retourner un `image.Rect(0,`0,`w,`h)`.

`ColorModel` doit retourner `color.RGBAModel`.

`At` doit retourner une couleur, la valeur `v` au dernier générateur d'image correspond à `color.RGBA{v,`v,`255,`255}` dans celui-ci.

.play methods/exercise-images.go

* Félicitations !

Vous avez terminé cette leçon !

Vous pouvez revenir à la liste des [[/list][modules]] pour trouver ce qu'il faut apprendre à côté, ou continuer avec la [[javascript:click('.next-page')][leçon suivante]].
